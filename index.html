<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>

  <script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.134.0';
    // Votre code JavaScript ici
  
    // Déclaration des variables globales
    let scene, camera, renderer, cube;
    let isInteracting = false;
    let lastTouchX, lastTouchY;
    let targetQuaternion = new THREE.Quaternion();
    let targetScale = new THREE.Vector3(1, 1, 1);
    let smoothFactor = 0.1;

    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    // Chargement des sons
    const sounds = [
        new Audio('1.mp3'),
        new Audio('2.mp3'),
        new Audio('3.mp3'),
        new Audio('4.mp3'),
        new Audio('5.mp3'),
        new Audio('6.mp3'),
        ];

        const gainNodes = [];

        let soundsReady = 0;

    // Configuration des sons en boucle et attente de leur chargement
    for (let i = 0; i < sounds.length; i++) {
        const sound = sounds[i];
        sound.loop = true;
        sound.addEventListener('canplaythrough', onSoundReady, false);

        const gainNode = audioContext.createGain();
        gainNode.gain.value = 0;

        const source = audioContext.createMediaElementSource(sound);
        source.connect(gainNode);
        gainNode.connect(audioContext.destination);

        gainNodes.push(gainNode);
    }

    // Met à jour les volumes des sons en fonction de la visibilité des faces
    function updateSoundVolumes() {
        const cameraDirection = new THREE.Vector3();
        camera.getWorldDirection(cameraDirection);

        const faceNormals = [
            new THREE.Vector3(1, 0, 0), //doite
            new THREE.Vector3(0, 1, 0), //haut
            new THREE.Vector3(0, 0, 1), //devant
            new THREE.Vector3(-1, 0, 0), //gauche
            new THREE.Vector3(0, -1, 0), //bas
            new THREE.Vector3(0, 0, -1), // arrière
        ];

        for (let i = 0; i < 6; i++) {
            const faceNormal = faceNormals[i].clone().applyMatrix4(cube.matrixWorld);
            const dotProduct = cameraDirection.dot(faceNormal);
            const frontVolume = Math.max(0, Math.min(1, dotProduct));
            const sideVolume = Math.max(0, Math.min(1, Math.abs(dotProduct) * 0.001));
            const targetVolume = Math.max(frontVolume, sideVolume);

            gainNodes[i].gain.setTargetAtTime(targetVolume, audioContext.currentTime, 0.02);
         }
    }   

    // Joue les sons en boucle    
    function startSounds() {
        for (let sound of sounds) {
        sound.play();
        }
    }

    // Incrémente le compteur, et démarre l'expérience lorsque tous les sons seront prêts
    function onSoundReady() {
        soundsReady++;
        if (soundsReady === sounds.length) {
        startExperience();
        }   
    }


    // Initialise la scène, la caméra, le rendu et le cube
    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0xffffff); // Couleur de fond blanc
      document.body.appendChild(renderer.domElement);

      const loader = new THREE.TextureLoader();

      const materials = [
        new THREE.MeshBasicMaterial({ map: loader.load('4.png') }), // Associé à '1.mp3'
        new THREE.MeshBasicMaterial({ map: loader.load('1.png') }), // Associé à '2.mp3'
        new THREE.MeshBasicMaterial({ map: loader.load('5.png') }), // Associé à '3.mp3'
        new THREE.MeshBasicMaterial({ map: loader.load('2.png') }), // Associé à '4.mp3'
        new THREE.MeshBasicMaterial({ map: loader.load('6.png') }), // Associé à '5.mp3'
        new THREE.MeshBasicMaterial({ map: loader.load('3.png') }), // Associé à '6.mp3'
      ];

      const geometry = new THREE.BoxGeometry(3.5, 3.5, 3.5); // Taille du cube
      cube = new THREE.Mesh(geometry, materials);
      scene.add(cube);

      camera.position.z = 7; // Ajustement de la position de la caméra pour voir le cube plus gros

      // Ajout des gestionnaires d'événements pour la souris
      document.addEventListener('mousedown', startInteraction, false);
      document.addEventListener('mouseup', endInteraction, false);
      document.addEventListener('mousemove', rotateCube, false);
      document.addEventListener('wheel', resizeCube, { passive: false });

      // Ajout des gestionnaires d'événements pour les écrans tactiles
      document.addEventListener('touchstart', startInteraction, false);
      document.addEventListener('touchend', endInteraction, false);
      document.addEventListener('touchcancel', endInteraction, false);
      document.addEventListener('touchmove', rotateCubeTouch, false);
      document.addEventListener('gesturechange', resizeCubeTouch, false);
    }

    // Fonctions pour gérer l'interaction avec le cube
    function startInteraction() {
      isInteracting = true;
    }

    function endInteraction() {
      isInteracting = false;
      lastTouchX = null; // Réinitialisez lastTouchX
      lastTouchY = null; // Réinitialisez lastTouchY
    }

    // Rotation du cube avec la souris
    function rotateCube(event) {
      if (isInteracting) {
        const deltaY = event.movementY * 0.005;
        const deltaX = event.movementX * 0.005;
        const axis = new THREE.Vector3(deltaY, deltaX, 0).normalize();
        const angle = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        const quaternion = new THREE.Quaternion().setFromAxisAngle(axis, angle);

        targetQuaternion.multiplyQuaternions(quaternion, targetQuaternion);
      }
    }

    // Rotation du cube avec les écrans tactiles
    function rotateCubeTouch(event) {
      event.preventDefault();
      if (isInteracting && event.touches.length === 1) {
        const touch = event.touches[0];
        const deltaX = lastTouchX ? touch.clientX - lastTouchX : 0;
        const deltaY = lastTouchY ? touch.clientY - lastTouchY : 0;
        const axis = new THREE.Vector3(-deltaY * 0.005, -deltaX * 0.005, 0).normalize();
        const angle = Math.sqrt(deltaX * deltaX + deltaY * deltaY) * 0.005;
        const quaternion = new THREE.Quaternion().setFromAxisAngle(axis, angle);

        targetQuaternion.multiplyQuaternions(quaternion, targetQuaternion);

        lastTouchX = touch.clientX;
        lastTouchY = touch.clientY;
      }
    }

    // Redimensionnement du cube avec la souris
    function resizeCube(event) {
      event.preventDefault(); // Empêcher le défilement de la page
      const scaleChange = event.deltaY < 0 ? 1.1 : 0.9;
      targetScale.multiplyScalar(scaleChange);
    }

    // Redimensionnement du cube avec les écrans tactiles
    function resizeCubeTouch(event) {
      event.preventDefault();
      if (event.scale !== undefined) {
        const newScale = event.scale;
        targetScale.set(newScale, newScale, newScale);
      }
    }
    
    function startExperience() {
        init();
        animate();
        startSounds();
    }

    // Fonction d'animation principale
    function animate() {
      requestAnimationFrame(animate);
      cube.quaternion.slerp(targetQuaternion, smoothFactor);
      cube.scale.lerp(targetScale, smoothFactor);
      updateSoundVolumes(); // Met à jour les volumes des sons en fonction des faces visibles
      renderer.render(scene, camera);
    }


  </script>
</body>
</html>
